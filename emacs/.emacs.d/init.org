#+TITLE: EXCmacs
#+AUTHOR: Marcelo Mendez
#+PROPERTY: header-args :tangle yes
#+STARTUP: overview

* About

Welcome to my Emacs configuration! The entire init file is written in Org mode, to keep it literate and easy to modify! I got inspired from [[https://github.com/larstvei/dot-emacs][this config]], and you might see some similarities.

I try to make this config easy to set up, so it should work on a normal Emacs install without many dependencies. Try it out /!!/

Since I use so many machines, I do use ~GNU stow~ to manage my dotfiles and have them all symlinked together. To install it with ~stow~, use

#+begin_src sh :tangle no
  brew install git stow

  git clone https://github.com/marceloexc/excverse

  cd excverse/

  stow -t "$HOME" emacs # or, just move everything inside of emacs/.emacs.d into ~/.emacs.d/ if you don't want to use stow
#+end_src

On first run it should install a bunch of packages (this might take a while),
and you might have to restart your Emacs the first time. If you experience
bugs, please let me know!

* Meta

  All changes to the configuration should be done in =init.org=, *not* in
  =init.el=. Any changes in the =init.el= will be overwritten by saving
  =init.org=. The =init.el= in this repo should not be tracked by git, and is
  replaced the first time Emacs is started (assuming it has been renamed to
  =~/.emacs.d=).

  Emacs can't load =.org=-files directly, but =org-mode= provides functions to
  extract the code blocks and write them to a file. There are multiple ways of
  handling this; like suggested by [[http://emacs.stackexchange.com/questions/3143/can-i-use-org-mode-to-structure-my-emacs-or-other-el-configuration-file][this StackOverflow post]], one could just use
  =org-babel-load-file=, but I had problems with byte-compilation. Previously I
  tracked both the =org.=- and =el.=-files, but the git commits got a little
  messy. So here is a new approach.

  When this configuration is loaded for the first time, the ~init.el~ is the
  file that is loaded. It looks like this:

  #+begin_src emacs-lisp :tangle no

  ;; This file replaces itself with the actual configuration at first run.

  ;; We can't tangle without org!
  (require 'org)
  ;; Open the configuration
  (find-file (concat user-emacs-directory "init.org"))
  ;; tangle it
  (org-babel-tangle)
  ;; load it
  (load-file (concat user-emacs-directory "init.el"))
  ;; finally byte-compile it
  (byte-compile-file (concat user-emacs-directory "init.el"))

  #+end_src

  It tangles the org-file, so that this file is overwritten with the actual
  configuration.

  There is no reason to track the =init.el= that is generated; by running the
  following command =git= will not bother tracking it:

  #+begin_src sh :tangle no

  git update-index --assume-unchanged init.el

  #+end_src

  If one wishes to make changes to the repo-version of =init.el= start tracking
  again with:

  #+begin_src sh :tangle no

  git update-index --no-assume-unchanged init.el

  #+end_src

  I want lexical scoping for the init-file, which can be specified in the
  header. The first line of the configuration is as follows:

  #+begin_src emacs-lisp

  ;;; -*- lexical-binding: t -*-

  #+end_src

  The =init.el= should (after the first run) mirror the source blocks in the
  =init.org=. We can use =C-c C-v t= to run =org-babel-tangle=, which extracts
  the code blocks from the current file into a source-specific file (in this
  case a =.el=-file).

  To avoid doing this each time a change is made we can add a function to the
  =after-save-hook= ensuring to always tangle and byte-compile the
  =org=-document after changes.

  #+begin_src emacs-lisp
  (defun tangle-init ()
    "If the current buffer is init.org the code-blocks are
  tangled, and the tangled file is compiled."
    (when (equal (buffer-file-name)
                 (expand-file-name (concat user-emacs-directory "init.org")))
      ;; Avoid running hooks when tangling.
      (let ((prog-mode-hook nil))
        (org-babel-tangle)
        (byte-compile-file (concat user-emacs-directory "init.el")))))

  (add-hook 'after-save-hook 'tangle-init)
  #+end_src

  I'd like to keep a few settings private, so we load a =private.el= if it
  exists after the init-file has loaded.

  #+begin_src emacs-lisp

  (add-hook
   'after-init-hook
   (lambda ()
     (let ((private-file (concat user-emacs-directory "private.el")))
       (when (file-exists-p private-file)
         (load-file private-file))
       (when custom-file
         (load-file custom-file))
       (server-start))))

  #+end_src

** Faster startup

   A common optimization is to temporarily disable garbage collection during
   initialization. Here, we set the ~gc-cons-threshold~ to a ridiculously large
   number, and restore the default value after initialization.

   #+begin_src emacs-lisp :tangle early-init.el
     (setq gc-cons-threshold most-positive-fixnum)
     (add-hook 'after-init-hook
               (lambda ()
                 (setq gc-cons-threshold (* 1024 1024 20))))

     (kill-buffer "*scratch*")

   #+end_src
   
** Packages
  
  John Wiegley's extremely popular [[https://github.com/jwiegley/use-package][use-package]] was included in [[https://lists.gnu.org/archive/html/emacs-devel/2022-12/msg00261.html][Emacs 29]]. It
  provides a powerful macro for isolating package configuration. After ignoring
  this for a decade, I'll budge and give it a whirl.

  #+begin_src emacs-lisp

      (require 'use-package)
    (setq use-package-always-ensure t)
    (setq use-package-compute-statistics t)
    (setq package-install-upgrade-built-in t)
  #+end_src

  Packages can be fetched from different mirrors, [[http://melpa.milkbox.net/#/][melpa]] is the largest archive
  and is well maintained.

  #+begin_src emacs-lisp

  (setq package-archives
        '(("GNU ELPA"     . "https://elpa.gnu.org/packages/")
          ("MELPA Stable" . "https://stable.melpa.org/packages/")
          ("MELPA"        . "https://melpa.org/packages/"))
        package-archive-priorities
        '(("GNU ELPA"     . 10)
          ("MELPA"        . 5)
          ("MELPA Stable" . 0)))
  

  #+end_src
  
* Sane defaults

  These are what /I/ consider to be saner defaults.

  Set =utf-8= as preferred coding system.

  #+begin_src emacs-lisp

  (set-language-environment "UTF-8")
  (prefer-coding-system 'utf-8)

  #+end_src

  We can set variables to whatever value we'd like using =setq=.

  #+begin_src emacs-lisp

    (setq auto-revert-interval 1            ; Refresh buffers fast
          default-input-method "TeX"        ; Use TeX when toggling input method
          echo-keystrokes 0.1               ; Show keystrokes asap
          frame-inhibit-implied-resize 1    ; Don't resize frame implicitly
          inhibit-startup-screen nil          ; No splash screen please
          recentf-max-saved-items 10000     ; Show more recent files
          ring-bell-function 'ignore        ; Quiet
          scroll-margin 1                   ; Space between cursor and top/bottom
          sentence-end-double-space nil     ; No double space
          custom-file                       ; Customizations in a separate file
          (concat user-emacs-directory "custom.el"))
    ;; Some mac-bindings interfere with Emacs bindings.
    (when (boundp 'mac-pass-command-to-system)
      (setq mac-pass-command-to-system nil))

  #+end_src

  Some variables are buffer-local, so changing them using =setq= will only
  change them in a single buffer. Using =setq-default= we change the
  buffer-local variable's default value.

  #+begin_src emacs-lisp

  (setq-default tab-width 4                       ; Smaller tabs
                split-width-threshold 160         ; Split verticly by default
                split-height-threshold nil        ; Split verticly by default
                frame-resize-pixelwise t)          ; Fine-grained frame resize


  #+end_src

  The =load-path= specifies where Emacs should look for =.el=-files (or
  Emacs lisp files). I have a directory called =site-lisp= where I keep all
  extensions that have been installed manually (these are mostly my own
  projects).

  #+begin_src emacs-lisp

  (let ((default-directory (concat user-emacs-directory "site-lisp/")))
    (when (file-exists-p default-directory)
      (setq load-path
            (append
             (let ((load-path (copy-sequence load-path)))
               (normal-top-level-add-subdirs-to-load-path)) load-path))))

  #+end_src

  Answering /yes/ and /no/ to each question from Emacs can be tedious, a single
  /y/ or /n/ will suffice.

  #+begin_src emacs-lisp

  (fset 'yes-or-no-p 'y-or-n-p)

  #+end_src

  To avoid file system clutter we put all auto saved files in a single
  directory.

  #+begin_src emacs-lisp

  (defvar emacs-autosave-directory
    (concat user-emacs-directory "autosaves/")
    "This variable dictates where to put auto saves. It is set to a
    directory called autosaves located wherever your .emacs.d/ is
    located.")

  ;; Sets all files to be backed up and auto saved in a single directory.
  (setq backup-directory-alist
        `((".*" . ,emacs-autosave-directory))
        auto-save-file-name-transforms
        `((".*" ,emacs-autosave-directory t)))

  #+end_src

  By default the =narrow-to-region= command is disabled and issues a
  warning, because it might confuse new users. I find it useful sometimes,
  and don't want to be warned.

  #+begin_src emacs-lisp

  (put 'narrow-to-region 'disabled nil)

  #+end_src

  Automaticly revert =doc-view=-buffers when the file changes on disk.

  #+begin_src emacs-lisp

  (add-hook 'doc-view-mode-hook 'auto-revert-mode)

  #+end_src

Automatically enable line numbers in buffers everytime I enter a "programming" mode

#+begin_src emacs-lisp
  (add-hook 'prog-mode-hook 'display-line-numbers-mode)
#+end_src

MarceloEXC talking here: I actually have a ~CUA~-ish type of setup going on in
terms of normal keybindings.

#+begin_src emacs-lisp

  ;; when on mac
  (when (eq system-type 'darwin)
    (setq mac-command-modifier 'meta) ; set cmd to meta
    (setq mac-option-modifier nil)
    (add-to-list 'default-frame-alist '(ns-transparent-titlebar . t)) ; configure title bar
    (add-to-list 'default-frame-alist '(ns-appearance . 'nil)))
#+end_src

And then some equivalents for linux systems...

#+begin_src emacs-lisp
  (when (eq system-type 'gnu/linux)
    (bind-keys ("C-s" . save-buffer)
               ("C-v" . yank)
               ("C-z" . undo-tree-undo)
               ("C-w" . kill-buffer)
               ("C-f" . +default/search-buffer)))
#+end_src

And I will a single ESC key to execute ~keyboard-quit~ instead of ESC ESC ESC...however, I don't want to do ~keyboard-escape-quit~ because then it closes every single one of my windows!

Instead, we use a custom function that I got [[https://old.reddit.com/r/emacs/comments/e5nady/redefined_esc_esc_esc_to_save_my_sanity_it_worked/][from here]]...

#+begin_src emacs-lisp
  (require 'cl-lib)
  (defun my-keyboard-escape-quit (fun &rest args)
    (cl-letf (((symbol-function 'one-window-p) (lambda (&rest _) t)))
      (apply fun args)))
  (advice-add 'keyboard-escape-quit :around #'my-keyboard-escape-quit)

  (if (display-graphic-p)
      (global-set-key (kbd "<escape>") 'keyboard-escape-quit)
    ;; Terminal environment: ESC -> C-g
    (global-set-key (kbd "<escape>") 'keyboard-quit))
#+end_src

easy dired hacks...

#+begin_src emacs-lisp

  ;; Make dired less verbose
  (require 'dired)
  
  (add-hook 'dired-mode-hook (lambda () (dired-hide-details-mode 1)))
  ;; Reuse current buffer when navigating directories
  (put 'dired-find-alternate-file 'disabled nil)

  ;; Use human-readable sizes
  (setq dired-human-readable-size t)

  (define-key dired-mode-map [mouse-2] 'dired-find-alternate-file)
  (define-key dired-mode-map (kbd "RET") 'dired-find-alternate-file)

  (add-hook 'dired-mode-hook 'visual-line-mode)

  ;;lets see if this works...
  (defun my-dired-open-file-in-new-buffer ()
    "Open file at point in a new buffer, keeping Dired open."
    (interactive)
    (let ((file (dired-get-file-for-visit)))
      (when (file-regular-p file)
        (find-file-other-window file)
        (delete-other-windows)))) ; makes it fullscreen
  (define-key dired-mode-map (kbd "o") #'my-dired-open-file-in-new-buffer)


  ;;end

  (when (require 'all-the-icons nil t)
    (add-hook 'dired-mode-hook 'all-the-icons-dired-mode))
#+end_src

enable flyspell mode for word spell checking
#+begin_src emacs-lisp
  ;; (flyspell-mode 1)
#+end_src

We will also disable compilation warnings since they get VERY annoying

#+begin_src emacs-lisp
(setq native-comp-async-report-warnings-errors nil)
#+end_src

make some adjustments to the modeline

#+begin_src emacs-lisp
  (define-key mode-line-buffer-identification-keymap
              [mode-line mouse-1]
              'mouse-buffer-menu)
#+end_src

docview scrolling should be continuous (i.e., when scrolling through PDFs)

#+begin_src emacs-lisp
  (setq doc-view-continuous t)
#+end_src

add minions mode for a non cluttered menu bar

#+begin_src emacs-lisp
  (use-package minions
    :ensure t
    :config
    (setq
      minions-direct '(flycheck-mode pyvenv-mode))
    (minions-mode 1))
#+end_src

and finally, enable mouse support when using emacs in the terminal (-nw flag)

#+begin_src emacs-lisp
(xterm-mouse-mode)
#+end_src
* Visual
  Here im adding a way to have my popup winodws controlled once and for al
  #+begin_src emacs-lisp
      (use-package popwin
            :ensure t
            :config
            (popwin-mode 1))

      (use-package pulsar
    :ensure t
    :config
    ;; Define the commands that trigger the pulse effect
    (setq pulsar-pulse-functions
          '(recenter-top-bottom
            move-to-window-line-top-bottom
            reposition-window
            bookmark-jump
            other-window
            delete-window
            delete-other-windows
            forward-page
            backward-page
            scroll-up-command
            scroll-down-command
            windmove-right
            windmove-left
            windmove-up
            windmove-down
            org-cycle
            kill-region
            yank
            undo-tree-undo
            org-next-visible-heading
            org-previous-visible-heading
            org-forward-heading-same-level
            org-backward-heading-same-level
            outline-next-visible-heading
            outline-previous-visible-heading
            outline-forward-same-level
            outline-backward-same-level))

    ;; Set the pulse duration
    (setq pulsar-delay 0.1) ;; duration in seconds

    ;; Enable pulsar mode globally
    (pulsar-global-mode 1)

    ;; Optional: Set pulsar face colors (if desired)
    (setq pulsar-face 'pulsar-magenta)
    (setq pulsar-highlight-face 'pulsar-yellow))
  #+end_src

I also hate the way EMACS treats native scrollbars...

#+begin_src emacs-lisp

  (use-package mlscroll
    :ensure t
    :init
    (setq mlscroll-width-chars 15)
    (setq mlscroll-border 2)
    :config 
    (mlscroll-mode 1))
#+end_src

And disable the ones that come with the GUI

#+begin_src emacs-lisp
  (scroll-bar-mode 0)
#+end_src

use nerd-icons instead of all-the-icons (i have some issue with it)

#+begin_src emacs-lisp
  (use-package nerd-icons)

  (use-package nerd-icons-dired
    :hook
    (dired-mode . nerd-icons-dired-mode))
#+end_src
** Font

   #+begin_src emacs-lisp
     (when (member "Berkeley Mono" (font-family-list))
            (when (eq system-type 'darwin)
              (set-face-attribute 'default nil :font "Berkeley Mono-14" :weight 'normal))
            (when (eq system-type 'gnu/linux)
              (set-face-attribute 'default nil :font "Berkeley Mono-10.5")))
   #+end_src

#+begin_src emacs-lisp
  (defun +my--set-common-fonts (family height)
    (let ((mode-line-box `(:line-width 7 :color ,(face-background 'mode-line) :style nil))
          (mode-line-inactive-box `(:line-width 7 :color ,(face-background 'mode-line-inactive) :style nil)))
      ;; Mode line fonts
      (set-face-attribute 'mode-line nil
                          :family family
                          :height height
                          :weight 'normal
                          :box mode-line-box)
      (set-face-attribute 'mode-line-inactive nil
                          :family family
                          :height height
                          :weight 'normal
                          :box mode-line-inactive-box)
      ;; Centaur tabs fonts
      (dolist (face '(centaur-tabs-default
                      centaur-tabs-selected
                      centaur-tabs-unselected
                      centaur-tabs-selected-modified
                      centaur-tabs-unselected-modified))
        (set-face-attribute face nil
                            :family family
                            :height height
                            :weight 'normal))))

  (defun +my-set-custom-fonts ()
    (interactive)
    (cond
     ((eq system-type 'darwin)
      (+my--set-common-fonts "SF Pro Text" 130))
     ((eq system-type 'gnu/linux)
      (+my--set-common-fonts "Cantarell" 100))))
#+end_src

** Centering with Olivetti

   [[https://github.com/rnkn/olivetti][Olivetti]] is a package that simply centers the text of a buffer. It is very
   simple and beautiful. The default width is just a bit short.

   #+begin_src emacs-lisp

   ;; Minor mode for a nice writing environment
   (use-package olivetti
     :defer t
     :config
     (setq-default olivetti-body-width 130))

;; make it run automatically

(dolist (f '(org-mode-hook text-mode-hook))
  (add-hook f #'olivetti-mode))

   #+end_src

** Dashboard
Dash board provides a nice welcome.

   #+begin_src emacs-lisp
     ;; Optimize ffap loading which dashboard depends on
     (setq ffap-require-prefix t)  ; Only activate ffap features when explicitly requested
     (with-eval-after-load 'ffap
       (setq ffap-machine-p-known 'reject)  ; Disable remote file name completion
       (setq ffap-url-regexp nil))          ; Disable URL features

     (use-package dashboard
       :init 
       (setq dashboard-projects-backend 'project-el
             dashboard-banner-logo-title nil
             dashboard-center-content t
             dashboard-set-footer nil
             dashboard-page-separator "\n\n\n"
             dashboard-items '((projects . 15)
                              (recents  . 15)
                              (bookmarks . 5)))
  
       (dashboard-setup-startup-hook))
   #+end_src

** Toolbar

Remove some useless (to me) toolbar items 
#+begin_src emacs-lisp
  (when (> emacs-major-version 28)
    (define-key global-map [menu-bar tools encryption-decryption] nil t)
    (define-key global-map [menu-bar tools calendar] nil t)
    (define-key global-map [menu-bar tools simple-calculator] nil t)
    (define-key global-map [menu-bar tools gdb] nil t)
    (define-key global-map [menu-bar tools gnus] nil t)
    (define-key global-map [menu-bar tools calc] nil t)
    (define-key global-map [menu-bar tools semantic] nil t)
    (define-key global-map [menu-bar tools rmail] nil t)
    (define-key global-map [menu-bar tools compose-mail] nil t)
  )
#+end_src

Change the default toolbar title format (I think having my system name is cool, but I would want it to say ~yggdrasil~, instead of ~yggdrasil.local~, so I guess I'll just remove it)

#+begin_src emacs-lisp
  ;;(setq frame-title-format '(multiple-frames "%b"
    ;;               ("" "%b - GNU Emacs")))
#+end_src
** Tabs

Use centaur tabs for the tab bar

#+begin_src emacs-lisp
  (use-package centaur-tabs
	:demand
	:config
	(centaur-tabs-mode t)
	(setq centaur-tabs-height 24
		  centaur-tabs-show-navigation-buttons t
		  centaur-tabs-set-modified-marker t
		  centaur-tabs-set-bar 'over
		  centaur-tabs-icon-type 'nerd-icons
		  centaur-tabs-label-fixed-length 14
		  centaur-tabs-show-count nil
		  centaur-tabs-style "bar"
		  centaur-tabs-set-icons t
		  ;;centaur-tabs-excluded-prefixes '("*")
		  centaur-tabs-exclude-buffers '("*Minibuf-1*" "*which-key*")
		  )
	:bind
	("C-<prior>" . centaur-tabs-backward)
	("C-<next>" . centaur-tabs-forward))

  (defun my-centaur-tabs-buffer-groups ()
	"Custom groupings for Centaur Tabs."
	(list
	 (cond
	  ;; Only specific utility modes go to 'Fundamental'
	  ((member (buffer-name) '("*compile*" "*Minibuf-1*" "*dashboard*" "*Messages*" "*helm*" "*Async-native-compile-log*" "*Compile-Log*" "*xref*" "magit-*" "*Completions*"))
	   "Fundamental")
	  ;; Everything else goes to 'Main'
	  (t "Main"))))

  (defun centaur-tabs-hide-tab (x)
	"Do no to show buffer X in tabs."
	(let ((name (format "%s" x)))
	  (or
	   ;; Current window is not dedicated window.
	   (window-dedicated-p (selected-window))

	   ;; Buffer name not match below blacklist.
	   (string-prefix-p "*epc" name)
	   (string-prefix-p "*helm" name)
	   (string-prefix-p "*Helm" name)
	   (string-prefix-p "*which" name)
	   (string-prefix-p "*Compile-Log*" name)
	   (string-prefix-p "*lsp" name)
	   (string-prefix-p "*company" name)
	   (string-prefix-p "*Flycheck" name)
	   (string-prefix-p "*tramp" name)
	   (string-prefix-p " *Mini" name)
	   (string-prefix-p "*straight" name)
	   (string-prefix-p "*which-key*" name)
	   (string-prefix-p " *temp" name)
	   (string-prefix-p "*mybuf" name)
	   (string-prefix-p "*Org" name)
	   )))

  (setq centaur-tabs-buffer-groups-function 'my-centaur-tabs-buffer-groups)
  (setq centaur-tabs-hide-tab-function 'centaur-tabs-hide-tab)
#+end_src
** Mode line

Add an "X" to the modeline to close the window. Only shows up when there are more than two windows on current buffer

#+begin_src emacs-lisp
  (defun my/close-clicked-window (event)
    "Close the window that was clicked on."
    (interactive "e")
    (let ((window (posn-window (event-start event))))
      (when (window-live-p window)
        (delete-window window))))

  (defvar my/close-window-modeline-map
    (let ((map (make-sparse-keymap)))
      (define-key map [mode-line mouse-1] 'my/close-clicked-window)
      map)
    "Keymap for the close window button in the mode line.")

  (defun my/close-window-modeline-construct ()
    "Construct a clickable [×] for the mode line to close windows.
  Only appears when there are multiple windows in the frame."
    (if (> (count-windows) 1)
        (propertize " ☒ "
                    'local-map my/close-window-modeline-map
                    'mouse-face 'mode-line-highlight
                    'face '(:foreground "red" :height 150)
                    'help-echo "Click to close this window")
      ""))

  ;; Insert at the beginning of the mode-line-format
  (setq-default mode-line-format
                (cons '(:eval (my/close-window-modeline-construct))
                      mode-line-format))

  ;; Force update of all mode lines
  (force-mode-line-update t)
#+end_src
** File Navigation

Treemacs is good for project-style navigation

#+begin_src emacs-lisp

  (use-package treemacs
    :ensure t
    :defer t
    :config (progn (treemacs-follow-mode t))
    :init)

  (use-package treemacs-tab-bar ;;treemacs-tab-bar if you use tab-bar-mode
    :after (treemacs)
    :ensure t
    :config (treemacs-set-scope-type 'Tabs))
#+end_src

However now I'm really trying it out with sr-speedbar...

#+begin_src emacs-lisp
  (use-package sr-speedbar)
#+end_src
** TODO Theme

set custom themes as safe (so that we don't get annoyed by a prompt to trust our theme

#+begin_src emacs-lisp

  (custom-set-variables
   '(custom-safe-themes t))

#+end_src

install auto dark

#+begin_src emacs-lisp
  (use-package auto-dark
    :ensure t
    :custom
    (auto-dark-themes '((ef-elea-dark) (modus-operandi-tinted)))
    :config (setq auto-dark-allow-osascript t)
    :hook (auto-dark-dark-mode . (lambda () (+my-set-custom-fonts)))
          (auto-dark-light-mode . (lambda () (+my-set-custom-fonts)))
  
    :init (auto-dark-mode))

  (+my-set-custom-fonts)
#+end_src


#+begin_src emacs-lisp
  (use-package ef-themes)
  (use-package modus-themes)
  (use-package adwaita-dark-theme)
  (use-package doom-themes
    :ensure t
    :init
    (doom-themes-org-config))
  (require 'ef-themes)
  (require 'modus-themes)

#+end_src

And solaire mode for better readability

#+begin_src emacs-lisp
  (use-package solaire-mode
    :init
    (solaire-global-mode +1))
#+end_src
* macOS specific

The package [[https://github.com/purcell/exec-path-from-shell][exec-path-from-shell]] synchronizes environment variables from the
shell to Emacs. This makes it a lot easier to deal with external programs on
macOS.

  #+begin_src emacs-lisp

  (use-package exec-path-from-shell
    :if (memq window-system '(mac ns))
    :config
    (exec-path-from-shell-initialize))

  #+end_src

I had some problems with Dired, and this seems to have solved it. I /think/
the solutions was from [[https://stackoverflow.com/questions/4076360/error-in-dired-sorting-on-os-x][here]], and my problems were related, but not the same.

  #+begin_src emacs-lisp

  (use-package ls-lisp
    :ensure nil
    :if (memq window-system '(mac ns))
    :config
    (setq ls-lisp-use-insert-directory-program nil))
  
  #+end_src

  It is useful to be able to occasionally open the file associated with a
  buffer in macOS Finder.

  #+begin_src emacs-lisp

  (use-package reveal-in-osx-finder
    :if (memq window-system '(mac ns)))

  #+end_src

Fixing macos scrolling....

#+begin_src emacs-lisp
  (when (eq system-type 'darwin)

  (unless (package-installed-p 'ultra-scroll)
      (package-vc-install '(ultra-scroll :vc-backend Git :url  "https://github.com/jdtsmith/ultra-scroll"))))

  ;; function that returns true if we are running on emacs-mac exclusively
  (defun carbon-emacs-p ()
    (string-match-p "Carbon" (emacs-version)))


    (use-package ultra-scroll
      :if (carbon-emacs-p)
      ;:load-path "~/code/emacs/ultra-scroll-mac" ; if you git clone'd instead of package-vc-install
      :init
      (setq scroll-conservatively 3 ; important!
            scroll-margin 0)
      :config
      (ultra-scroll-mode 1))


    (defvar minibuffer-ultra-scroll-mac-mode--orig nil
    "Stores the original value of `ultra-scroll-mac-mode'.")

  (define-minor-mode minibuffer-ultra-scroll-mac-mode
    "Toggle `ultra-scroll-mac-mode' only in minibuffers."
    :init-value nil
    :global t
    (if minibuffer-ultra-scroll-mac-mode
        (setq minibuffer-ultra-scroll-mac-mode--orig ultra-scroll-mode
              ultra-scroll-mode nil)
      (setq ultra-scroll-mac-mode minibuffer-ultra-scroll-mac-mode--orig)))

  (if (carbon-emacs-p)
    (add-hook 'minibuffer-setup-hook #'minibuffer-ultra-scroll-mac-mode)
    (add-hook 'minibuffer-exit-hook (lambda () (minibuffer-ultra-scroll-mac-mode -1)))
    )


#+end_src

* Version control

  Have some visual indication where there are uncommitted changes.

  #+begin_src emacs-lisp

  ;; Highlight uncommitted changes using VC
  (use-package diff-hl
    :config
    (global-diff-hl-mode 1))

  #+end_src

** TODO Rename the parent header as "Project Management"

Use projectile 
#+begin_src emacs-lisp
  (use-package projectile
    :diminish projectile-mode
    :config (projectile-mode)
    :bind-keymap
    ("C-c p" . projectile-command-map)
    :init
    (setq projectile-switch-project-action #'projectile-dired))
#+end_src

* Completion UI

** Basic Completion packages (vertico, marginalia, etc)
  #+begin_src emacs-lisp

  ;; VERTical Interactive COmpletion
  (use-package vertico
    :init
    (vertico-mode 1)
    (vertico-mouse-mode 1)
    :config
    (setq vertico-count 20))

  #+end_src

  Use the built in ~savehist-mode~ to prioritize recently used commands.

  #+begin_src emacs-lisp

  ;; Save minibuffer history
  (use-package savehist
    :init
    (savehist-mode 1))

  #+end_src

  With [[https://github.com/minad/marginalia/][Marginalia]], we get better descriptions for commands inline.

  #+begin_src emacs-lisp

  ;; Enrich existing commands with completion annotations
  (use-package marginalia
    :init 
    (marginalia-mode 1))

  #+end_src

  Finally, make minibuffers scrollable

  #+begin_src emacs-lisp
(setq minibuffer-scroll-window t)
  #+end_src

   #+begin_src emacs-lisp
     (use-package company
       :ensure t
       :hook (after-init . global-company-mode) ; Enable globally after startup
       :bind ("M-/" . company-complete)       ; Quick trigger key
       :custom
       (company-minimum-prefix-length 2)       ; Start suggesting after 2 chars
       (company-idle-delay 0.2)                ; Faster suggestions (default: 0.5)
       (company-selection-wrap-around t)       ; Wrap around candidate list
       (company-tooltip-limit 10)              ; Show fewer candidates initially
       (company-dabbrev-downcase nil)          ; Case-sensitive suggestions
       (company-require-match 'never)          ; Allow arbitrary input
       (company-show-numbers t)                ; Show numbers for quick selection
       (company-frontends                      ; Cleaner UI
        '(company-pseudo-tooltip-frontend      ; Default popup
          company-echo-metadata-frontend)))    ; Show docs in echo area
   #+end_src

   I use corfu in concert with [[https://github.com/oantolin/orderless][orderless]]. 

  #+begin_src emacs-lisp

  ;; Emacs completion style that matches multiple regexps in any order
  (use-package orderless
    :config
    (setq completion-styles '(orderless basic partial-completion)
          completion-category-overrides '((file (styles basic partial-completion)))
          orderless-component-separator "[ |]"))

  #+end_src

** Navigation and searching

   The package [[https://github.com/minad/consult][Consult]] improves navigation and searching.


   #+begin_src emacs-lisp

  ;; Consulting completing-read
  (use-package consult
    :config
    (setq consult-preview-key (list :debounce 0.1 'any)))
   #+end_src


This is also a custom function i stole from doom emacs to have quick and easy CMD+F

#+begin_src emacs-lisp

(defun +default/search-buffer ()
  "Conduct a text search on the current buffer.
If a selection is active and multi-line, perform a search restricted to that
region.
If a selection is active and not multi-line, use the selection as the initial
input and search the whole buffer for it."
  (interactive)
  (let (start end multiline-p)
    (save-restriction
      (when (region-active-p)
        (setq start (region-beginning)
              end   (region-end)
              multiline-p (/= (line-number-at-pos start)
                              (line-number-at-pos end)))
        (deactivate-mark)
        (when multiline-p
          (narrow-to-region start end)))
      (if (and (featurep 'vertico)
               (fboundp 'consult-line))
          (if (and start end (not multiline-p))
              (consult-line
               (replace-regexp-in-string
                " " "\\\\ "
                (rxt-quote-pcre
                 (buffer-substring-no-properties start end))))
            (call-interactively #'consult-line))))))
#+end_src
* Spelling

Install ~undo-tree~

#+begin_src emacs-lisp
  (use-package undo-tree
    :ensure t
    :config (setq undo-tree-history-directory-alist '(("." . "~/.emacs.d/undo")))
    :init
    (global-undo-tree-mode))
#+end_src
** TODO Define word

   This super neat package looks up the word at point. I use it a lot!

   #+begin_src emacs-lisp :tangle no

   ;; display the definition of word at point
   (use-package define-word
     :defer t
     :bind (:map custom-bindings-map ("C-c D" . define-word-at-point)))

   #+end_src
* Programming
** Git

Use magit for git

#+begin_src emacs-lisp
  ;; make tabs appear in magit buffers
  (defun toggle-centaur-tabs-local-mode()
    (interactive)
    (call-interactively 'centaur-tabs-local-mode)
    (call-interactively 'centaur-tabs-local-mode))

  (use-package magit
    :ensure t
    :config
    (setq magit-display-buffer-function #'magit-display-buffer-fullframe-status-v1
          magit-diff-refine-hunk 'all)
    (add-hook 'magit-status-mode-hook 'toggle-centaur-tabs-local-mode))


#+end_src

** Languages
*** ELisp / Common Lisp / Clojure

Really, all I want is just some rainbow parenthesis...

#+begin_src emacs-lisp
  (use-package rainbow-delimiters
    :hook (emacs-lisp-mode . rainbow-delimiters-mode)
    :hook (common-lisp-mode . rainbow-delimiters-mode))
#+end_src


*** Swift

#+begin_src emacs-lisp
  (use-package swift-mode)
#+end_src

*** Web

#+begin_src emacs-lisp
  (use-package web-mode
	:ensure t
	:mode
	(("\\.phtml\\'" . web-mode)
	 ("\\.php\\'" . web-mode)
	 ("\\.tpl\\'" . web-mode)
	 ("\\.[agj]sp\\'" . web-mode)
	 ("\\.as[cp]x\\'" . web-mode)
	 ("\\.erb\\'" . web-mode)
	 ("\\.mustache\\'" . web-mode)
	 ("\\.html\\'" . web-mode)
	 ("\\.djhtml\\'" . web-mode)))
#+end_src

#+begin_src emacs-lisp
  (define-derived-mode astro-mode web-mode "astro")
  (setq auto-mode-alist
        (append '((".*\\.astro\\'" . astro-mode))
                auto-mode-alist))
#+end_src

#+begin_src emacs-lisp
  (use-package eglot
  :ensure t
  :config
  (add-to-list 'eglot-server-programs
               '(astro-mode . ("astro-ls" "--stdio"
                               :initializationOptions
                               (:typescript (:tsdk "./node_modules/typescript/lib")))))
  :init
  ;; auto start eglot for astro-mode
  (add-hook 'astro-mode-hook 'eglot-ensure))
#+end_src

*** GTK Blueprints
#+begin_src emacs-lisp
  (when (> emacs-major-version 28)
    (unless (package-installed-p 'blueprint-mode)
      (package-vc-install '(blueprint-mode :vc-backend Git :url "https://github.com/DrBluefall/blueprint-mode")))
    (add-to-list 'eglot-server-programs 
                 '(blueprint-mode . ("blueprint-compiler" "lsp"))))
#+end_src
*** Processing

#+begin_src emacs-lisp
  (use-package processing-mode)
  (use-package auto-virtualenv
    :hook (python-mode . auto-virtualenv-setup)
    :config
    (setq auto-virtualenv-verbose t) (setq auto-virtualenv-reload-lsp t))
#+end_src
*** Supercollider

#+begin_src emacs-lisp

  ;; its quite a process to get sclang installed, so just make it optional whenever user has a
  ;; .scd buffer

  (add-hook 'find-file-hook
            (lambda ()
              (when (string-match "\\.scd\\'" (buffer-file-name))
                (add-to-list 'load-path "/Users/marceloexc/Library/Application Support/SuperCollider/downloaded-quarks/scel/el")
                (require 'sclang)
                (setq exec-path (append exec-path '("/Applications/SuperCollider.app/Contents/MacOS/")))
                (message "Supercollider running! "))))


#+end_src
* Word Processing
** Org

  I use Org mode extensively. Some of these configurations may be unfortunate,
  but it is a bit impractical to change, as I have years worth of org-files and
  want to avoid having to reformat a lot of files.

  One example is =org-adapt-indentation=, which changed default value in
  version 9.5 of Org mode. Another is that I for some unknown reason decided to
  content within source content not be indented by two spaces (which is the
  default).

  #+begin_src emacs-lisp

    ;; Outline-based notes management and organizer
    (use-package org
      :ensure t
      :hook (org-mode . (lambda ()
                          (org-indent-mode)
                          (visual-line-mode 1)))
      :config
       ;; enable syntax highlighting in code blocks
      (setq org-src-fontify-natively t
            org-hide-emphasis-markers t
            org-pretty-entities t
            org-startup-folded t
            org-support-shift-select t
            org-src-preserve-indentation nil)
       ;; everything else

       (setq org-indirect-buffer-display 'current-window
                  org-enforce-todo-dependencies nil
                  org-fontify-done-headline t
                  org-fontify-quote-and-verse-blocks t
                  org-fontify-whole-heading-line t
                  org-todo-keywords
                  '((sequence
                     "TODO(t)"  ; A task that needs doing & is ready to do
                     "PROJ(p)"  ; A project, which usually contains other tasks
                     "LOOP(r)"  ; A recurring task
                     "STRT(s)"  ; A task that is in progress
                     "WAIT(w)"  ; Something external is holding up this task
                     "HOLD(h)"  ; This task is paused/on hold because of me
                     "IDEA(i)"  ; An unconfirmed and unapproved task or notion
                     "|"
                     "DONE(d)"  ; Task successfully completed
                     "KILL(k)") ; Task was cancelled, aborted, or is no longer applicable
                    (sequence
                     "[ ](T)"   ; A task that needs doing
                     "[-](S)"   ; Task is in progress
                     "[?](W)"   ; Task is being held up or paused
                     "|"
                     "[X](D)")  ; Task was completed
                    (sequence
                     "|"
                     "OKAY(o)"
                     "YES(y)"
                     "NO(n)"))
                  ))

      (custom-theme-set-faces
           'user
           `(org-level-3 ((t (:size 17))))
           `(org-level-2 ((t (:height 1.05))))
           `(org-level-1 ((t (:height 1.1)))))

    (custom-set-faces
     '(org-meta-line ((t (:height 0.8))))
     '(org-document-info-keyword ((t (:height 0.8)))))


  #+end_src

Set some default directories when note taking

#+begin_src emacs-lisp
  (with-eval-after-load 'org
    (setq org-directory "~/Documents/Notes")
    (setq org-default-notes-file (concat org-directory "/captured.org")))
  ;; this will ALWAYS be how my structure will be!

  (setq org-capture-templates
        '(("t" "Quick Thoughts" entry
           (file "~/Documents/Notes/Captured.org")
           "* %?\nEntered on %U\n")))

#+end_src

use org-modern to make everything pretty

#+begin_src emacs-lisp
  (use-package org-modern
      :ensure t
      :after org
      :config

      (setq org-hide-leading-stars t)
      ;; (setq org-indent-mode-turns-on-hiding-stars nil)
      (setq org-modern-hide-stars nil)

      (setq org-modern-fold-stars '(("◉" . "◉")
                                 ("○" . "○")
                                 ("◇" . "◇")
                                 ("✿" . "✿")))


      )

  (with-eval-after-load 'org (global-org-modern-mode))
#+end_src

 Also use ~org-superstar~

Install ~org-toc~

#+begin_src emacs-lisp
;; Install toc-org for auto Table of Contents
(use-package toc-org
  :ensure t
  :hook (org-mode . toc-org-enable)
  :config
  (setq toc-org-hrefify-default "gh"))
#+end_src

Use ~org-appear~ for better editing with fontified / prettyfied
content

#+begin_src emacs-lisp

  (use-package org-appear
      :ensure t
      :hook (org-mode . org-appear-mode))
	
#+end_src

And use org-tidy

#+begin_src emacs-lisp
  (use-package org-tidy
  :ensure t
  :hook
  (org-mode . org-tidy-mode))
#+end_src

We will use Denote for all of our notes

#+begin_src emacs-lisp

(use-package denote
  :ensure t
  :init)
#+end_src

And install ~htmlize~ for exporting ORG to HTML and having our code blocks have syntax highlighting

#+begin_src emacs-lisp
  (use-package htmlize
  :ensure t)
#+end_src

Use ~org-download~ for drag and drop images

#+begin_src emacs-lisp
  (use-package org-download
  :ensure t)
#+end_src

and ~org-ros~ for quick screenshots

#+begin_src emacs-lisp
  (use-package org-ros
    :ensure t)
#+end_src

Create a function to scale down every single image in an org document

#+begin_src emacs-lisp
  (setq org-display-remote-inline-images 'download)
  (setq org-image-actual-width 400)

  (defun add-width-attributes-to-images-in-region (start end)
    "Add #+attr_html: :width <user-input>px and #+attr_org: :width <user-input>px above all images in the selected region."
    (interactive "r")
    (if (use-region-p)
        (let ((width (read-string "Enter desired image width in pixels: ")))
          (when (string-match-p "^[0-9]+$" width)
            (save-excursion
              (narrow-to-region start end)
              (goto-char (point-min))
              (while (re-search-forward "\\[\\[\\(file:\\|http\\|https\\)?:?.*?\\(\\.png\\|\\.jpg\\|\\.jpeg\\|\\.gif\\|\\.svg\\)\\]\\(\\[.*?\\]\\)?\\]" nil t)
                (save-excursion
                  (goto-char (match-beginning 0))
                  (let ((attrs-exist (save-excursion
                                       (forward-line -2)
                                       (looking-at "^[ \t]*#\\+attr_html: :width [0-9]+px\n[ \t]*#\\+attr_org: :width [0-9]+px$"))))
                    (unless attrs-exist
                      (let ((indentation (current-indentation)))
                        (beginning-of-line)
                        (insert (make-string indentation ?\s) (format "#+attr_html: :width %spx\n" width)
                                (make-string indentation ?\s) (format "#+attr_org: :width %spx\n" width)))))))
              (widen))
            (message "Width attributes added to images in the selected region.")))
      (message "No region selected. Please select a region first.")))
#+end_src

Hiding keylines:

#+begin_src emacs-lisp 
  (defun my/org-hide-keywords ()
    (save-excursion
      (goto-char (point-min))
      (while (re-search-forward "^#\\+\\(.*\\):" nil t)
        (org-fold-region (line-beginning-position) (line-end-position) t))))

#+end_src

finally, org mouse

#+begin_src emacs-lisp

  (require 'org-mouse) ;; enable cool mouse features!
  (org-mode-restart)

#+end_src
** Latex
We set our default program for latex

#+begin_src emacs-lisp
  (setq org-latex-create-formula-image-program 'dvisvgm)

  (defun my/text-scale-adjust-latex-previews ()
    (pcase major-mode
      ('latex-mode
       (dolist (ov (overlays-in (point-min) (point-max)))
         (if (eq (overlay-get ov 'category)
                 'preview-overlay)
             (my/zoom-latex-preview ov))))
      ('org-mode
       (dolist (ov (overlays-in (point-min) (point-max)))
         (if (eq (overlay-get ov 'org-overlay-type)
                 'org-latex-overlay)
             (my/zoom-latex-preview ov))))))

  (defun my/zoom-latex-preview (ov)
    (overlay-put
     ov 'display
     (cons 'image
           (plist-put
            (cdr (overlay-get ov 'display))
            :scale (+ 1.0 (* 0.25 text-scale-mode-amount))))))

  (add-hook 'text-scale-mode-hook #'my/text-scale-adjust-latex-previews)

  
#+end_src

add fragtog support

#+begin_src emacs-lisp
  (use-package org-fragtog
  :after org  )

  (add-hook 'org-mode-hook 'org-fragtog-mode)
#+end_src
** Markdown

  #+begin_src emacs-lisp
(use-package markdown-mode
  :ensure t
  :mode ("README\\.md\\'" . gfm-mode)
  :init (setq markdown-command "multimarkdown")
  :bind (:map markdown-mode-map
         ("C-c C-e" . markdown-do)))
    (use-package grip-mode
  :ensure t
  :config
  (setq grip-update-after-change nil)
  (setq grip-preview-use-webkit t))  ;; Requires Emacs 27 or later

  #+end_src
** Spellchecking

#+begin_src emacs-lisp

  (add-hook 'org-mode-hook 'turn-on-flyspell)

#+end_src
** Easy integration with hugo

#+begin_src emacs-lisp

    (use-package easy-hugo
      :init
      (setq easy-hugo-server-flags "-D"))
#+end_src
* global-scale-mode

  These functions provide something close to ~text-scale-mode~, but for every
  buffer, including the minibuffer and mode line.

  #+begin_src emacs-lisp

  (let* ((default (face-attribute 'default :height))
         (size default))

    (defun global-scale-default ()
      (interactive)
      (global-scale-internal (setq size default)))

    (defun global-scale-up ()
      (interactive)
      (global-scale-internal (setq size (+ size 20))))

    (defun global-scale-down ()
      (interactive)
      (global-scale-internal (setq size (- size 20))))

    (defun global-scale-internal (arg)
      (set-face-attribute 'default (selected-frame) :height arg)
      (set-transient-map
       (let ((map (make-sparse-keymap)))
         (define-key map (kbd "s-=") 'global-scale-up)
         (define-key map (kbd "s-+") 'global-scale-up)
         (define-key map (kbd "s--") 'global-scale-down)
         (define-key map (kbd "s-0") 'global-scale-default) map))))

  #+end_src

* Which key

  [[https://github.com/justbur/emacs-which-key][Which key]] is nice for discoverability.

  #+begin_src emacs-lisp

      ;; Display available keybindings in popup
      (use-package which-key
          :config
          (setq which-key-idle-delay 0.1)        
          (setq which-key-idle-secondary-delay 0.1)
          (which-key-setup-minibuffer)

          (which-key-mode 1))

  #+end_src 
* Key bindings

Use this for all my keybindings:

If we're on mac, then use our own CUA keys...

TODO <insert here>

Otherwise, enable CUA on linux
#+begin_src emacs-lisp
  (cua-mode t)
  (setq cua-auto-tabify-rectanlges nil)
  (transient-mark-mode 1)
  (setq cua-keep-region-after-copy t)

  ;; (define-key key-translation-map (kbd "ESC") (kbd "C-g"))

  (when (eq system-type 'darwin)
    (setq mac-command-key-is-meta nil ;we want it to be SUPER
      mac-command-modifier 'super ;⌘=super-key (but can't use s-SPACE,TAB)
      mac-right-command-modifier 'meta ; meta-f/b are hard to reach otherwise
      mac-option-modifier 'meta    ;alt=meta=option
      mac-right-option-modifier nil ;retain compose characters, düde
      mac-right-control-modifier 'hyper
      mac-emulate-three-button-mouse t ; not ideal for secondary selection :(
      ;; mac-mouse-wheel-smooth-scroll t
      delete-by-moving-to-trash t
      browse-url-browser-function 'browse-url-default-macosx-browser
      trash-directory (expand-file-name ".Trash" (getenv "HOME")))

    (bind-keys ("s-s" . save-buffer)
           ("s-a" . mark-whole-buffer)
           ("s-`" . list-buffers)
           ("s-c" . kill-ring-save)
           ("s-m" . suspend-frame)
           ("s-t" . (lambda (arg) (interactive "p")
              (let ((mac-frame-tabbing t))
                (if (not (eq arg 4))
                    (make-frame)
                  (call-interactively #'find-file-other-frame)))))
           ("s-x" . kill-region)
           ("s-v" . yank)
           ("s-z" . undo-tree-undo)
           ("s-Z" . undo-tree-redo)
           ("s-w" . kill-this-buffer)
           ("s-{" . mac-previous-tab)
           ("s-}" . mac-next-tab)
           ("s-q" . kill-emacs)
           ("s-f" . +default/search-buffer)
           ("s-`" . other-window)
           ("s-/" . comment-line)
           ("S-s-<left>" . mac-previous-tab)
           ("S-<swipe-left>" . mac-previous-tab)
           ("S-s-<right>" . mac-next-tab)
           ("S-<swipe-right>" . mac-next-tab)
           ("s-n" . make-frame-command)
           ;; ("M-<tab>" . buffer-expose)
           ("s-|" . mac-toggle-tab-group-overview)
           ("s-M-t" . mac-move-tab-to-new-frame)
           ("S-s-M-<right>" . mac-move-tab-right)
           ("S-s-M-<left>" . mac-move-tab-left)))

  (when (eq system-type 'gnu/linux)
    (bind-keys
     ("C-s" . save-buffer)
     ("C-a" . mark-whole-buffer)
     ("C-`" . list-buffers)
     ("C-c" . kill-ring-save)
     ("C-t" . (lambda (arg) (interactive "p")
                (if (not (eq arg 4))
                    (make-frame)
                  (call-interactively #'find-file-other-frame))))
     ("C-x" . kill-region)
     ("C-v" . yank)
     ("C-z" . undo-tree-undo)
     ("C-Z" . undo-tree-redo)
     ("C-w" . kill-buffer)
     ("C-{" . previous-buffer)
     ("C-}" . next-buffer)
     ("C-q" . save-buffers-kill-terminal)
     ("C-f" . +default/search-buffer)
     ("C-`" . other-window)
     ("C-/" . comment-line)
     ("C-n" . make-frame-command)))


  (when (not (display-graphic-p))
    (setq xterm-extra-capabilities '(meta))
    (setq xterm-extra-capabilities '(modifyOtherKeys)))
#+end_src

Then use general...

#+begin_src emacs-lisp
  (use-package general
      :demand t)

  (general-create-definer map
        :prefix "M-a")

      ;; Define your keybindings
      (map
        :keymaps 'override

        "d" '(dired :which-key "Dired ")

        "b" '(consult-buffer :which-key "consult-buffer")

        ;;f for files
        "f" '(:ignore t :which-key "File")
        "ff" '(find-file :which-key "find-file")
        "fr" '(recentf-open :which-key "recentf-open")

        ;;n for notes (org mode, etc)
        "n" '(:ignore t :which-key "Notes")
        "nh" '(org-html-export-to-html :which-key "Export Org file as HTML")
        "ns" '(org-edit-src-code :which-key "Edit Org source code")
        "nm" '(easy-hugo-menu :which-key "Open Easy Hugo Menu")
        "nt" '(org-todo :which-key "Set TODO Keyword")
        "nd" '(org-deadline :which-key "Set Org Deadline")
        "ne" '(org-emphasize :which-key "Emphasize selected text")
        "nl" '(org-insert-link :whick-key "Insert Org Link")

        ;;r - restart mode only
        "r" '(:ignore t :which-key "Restart Emacs")
        "rr" '(restart-emacs :which-key "Confirm restart")

        ;;t - toggling stuff
        "t" '(:ignore t :which-key "Toggles")
        "tt" '(treemacs :which-key "Toggle Treemacs")
        "te" '(display-line-numbers-mode :which-key "Toggle Line Numbers")
        "to" '(olivetti-mode :which-key "Toggle Olivetti")
        "tm" '(demap-toggle :which-key "Toggle minimap")

        ;;l - Language server (with eglop
        "la" '(eglot-code-actions :which-key "Code Actions")
        "lr" '(eglot-rename :which-key "Rename in Project")
        "lh" '(eldoc :which-key "Eldoc")
        "ld" '(xref-find-definitions-at-mouse :which-key "Find def")
        "lR" '(eglot-reconnect :which-key "reconnect")

        ;;w for window
        "w" '(:ignores t :which-key "Window")
        "wd" '(delete-window :which-key "Delete Window")
        "wa" '(split-window-right :which-key "Vertical Split")
        "ws" '(split-window-below :which-key "Horizontal Split")
        "ww" '(other-window :which-key "Other Window")
        )
#+end_src

Disable some annoyances...(like delete-selection-mode and context menu mode)

#+begin_src emacs-lisp
  (context-menu-mode 1)
  (delete-selection-mode t)
#+end_src


